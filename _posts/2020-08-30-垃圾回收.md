---
layout: post
title: "垃圾回收"
date: 2020-08-30 
description: "性能优化"
tag: 前端技术
---

## 内存管理
人为的对内存进行申请、使用、释放。javascript中内存管理是自动的。

## 垃圾回收
垃圾回收就是javascript对于内存的管理。  
当对象不再被引用或者不能从全局对象上访问，就会被当作垃圾被javascript清理掉。

## GC算法
在垃圾回收的过程中不可避免需要查找，释放空间。对应的就会有不同的策略去执行这些操作，这些策略就被称作GC算法。下面会列举一些常见的GC算法。

## 引用计数算法
当一个对象被赋值给一个变量或者该对象可以在全局对象上访问到时，则引用数+1。当在进行垃圾回收时，那些引用计数为0的空间将被垃圾回收。    
缺点：当局部作用域中两个对象循环引用，这时候两个对象的引用数永远不为0。当局部作域执行完毕之后，内部的空间理应被释放，但因为引用数不为0而导致
没办法被回收，从而出现内存泄漏问题。

## 标记清除算法
从全局对象出发，对可以访问到的对象空间进行递归标记。而局部变量因为无法被全局对象引用，因而无法被到标记到，后续就会被当作垃圾回收。  
缺点：被回收的空间会以头部+内容域两部分当成一个块被存储起来，该内存块因为大小固定，后续我们新定义的变量所需空间无法与该内存块的空间大小匹配
上，从未导致改内存块无法被重新使用而导致浪费，产生的该问题我们把它称为“空间碎片化”。

## 标记整理算法
跟标记清除算法一样，会有两个阶段  
1、标记空间阶段 2、清除阶段  
第一个阶段和标记清除算法一样，第二阶段则优化了一下，会在清除开始前对没有被标记的空间进行整理，然后再进行回收。这样的目的是为了解决“空间碎片化”
的问题，让回收过后的空间可以最大化的被重新利用。

## V8受到亲睐的原因
1、即时编译
2、内存设有上限，之所以要设有上限，主要是web所需的空间不用太多，还有考虑内部的垃圾回收机制，内存越大所耗费时间
越多，因此将内存进行了限制

## V8用到的GC算法
* 分代回收
* 空间复制
* 标记清除
* 标记整理
* 标记增量

## 分代回收
V8会将内存空间分配成新生代内存区和老生代内存区两部分，在这两部分中会应用不同的算法进行垃圾回收

## 新生代对象
新生代对象存储的是局部作用域的对象  
垃圾回收的实现过程  
* 回收过程采用空间复制+标记整理算法
* 新生代内存区会被均分成两部分，分别叫from、to空间
* 我们把局部空间的对象存放在from空间
* 垃圾回收第一阶段：标记整理from空间的对象并拷贝至to空间
* 第二阶段：from和to空间进行交换，完成第二阶段，完成内存空间的释放  
那么局部变量有没有可能存放在老生代内存区？答案是：有的。在新生代内存区进行GC的过程只要满足下面其中一个
条件就可以晋升到老生代内存区：
1. 一轮GC后还存活的变量会被晋升
2. 当to的空间使用率超过25%时，所有的变量都会被晋升

## 老生代对象
老生代对象存储的是全局对象中的变量，或者闭包中使用到的变量
垃圾回收的实现过程  
* 主要采用标记清除算法，因为老生代的内存空间比较大，运用该算法的效率最高。次要采用标记整理、增量标记算计。
* 但晋升的过程中内存空间不够了，就会使用标记整理算法
* 标记增量算法主要针对的是垃圾回收的标记阶段，将需要标记的对象分割成几个部分，在代码执行的空档期来执行标记，从而最大程度上避免阻塞代码的执行。
